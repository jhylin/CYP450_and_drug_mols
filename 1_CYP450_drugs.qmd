---
title: "Cytochrome P450 (CYP) and small drug molecules"
subtitle: "CYP3A4 and 2D6 inhibitors"
author: Jennifer HY Lin
date: '2024-7-24'
draft: true
categories: 
    - Metabolism
    - Toxicology
    - Pandas
    - RDKit
    - ChEMBL database
    - Python
jupyter: python3
format: html
bibliography: references.bib
---

##### **Some introductions**

I initially wanted to work on something about drug toxicology without setting any goals or intentions on how this post would end (basically doing this as a free-style post) and currently I felt it would be more to do with metabolism, which was also directly linked to drug toxicity, an important area not to ignore during any therapeutic drug discovery and developmental work.

This post was sort of inspired by a recent commentary that talked about "avoidome" and DMPK-related proteins to avoid [@Fraser2024]. I also happened to encounter two other blog posts ([a post from D. Lowe](https://www.science.org/content/blog-post/john-keats-would-word), and [another one from P. Kenny](https://fbdd-lit.blogspot.com/2024/03/)) that have provided reviews on this commentary recently with interesting view points.

In a very rough sense, three main areas have been looked at (not exhaustive) with the aim to create safer therapeutic drugs: 

1. **Structural alerts** on compound substructures that were known to cause adverse drug effects or pan-assay interference compounds (PAINs)

    Many have looked into structural alerts (an example repo: [rd_filters](https://github.com/PatWalters/rd_filters)). ChEMBL database has already had a cheminformatic utils web service developed that provided structural alert computations for compounds. There were most likely much more efforts than these ones.

2. Toxicophores in relation to **human ether-a-go-go-related gene (hERG) potassium channel** (this might be similar to the first one actually)

    hERG potassium channel was also another frequently-looked-at aspect for drug toxicology due to its known effect leading to cardiac QT prolongations or more commonly known as arrhythmias.

3. **Cytochrome P450 enzymes** (CYP450, CYP isoenzymes, CYP or CYPs), the well-known ones were CYP3A4, 2D6, 1A2, 2C9 and 2C19

    CYP450 enzymes played a key role in the metabolism and toxicology parts of the ADMET process of drugs, all I wanted to do was to look into the relationship between CYP450 and small drug molecules to see if there was anything interesting for further explorations. This post would start with the two largest groups of CYP inhibitors, so focussing on CYP3A4 and 2D6 first.

Other useful categories involved drug-induced skin sensitisations and liver injuries and more.

While my focus was only on a very small cohort of small molecules relating to only two CYPs, it was also worth noting that there were actually more CYPs present as well, for example, CYP1A1, 2A6, 2B6, 2C8, 2E1, 2J2, 3A5 (note: amlodipine was a moderate CYP3A5 inhibitor and would be looked at below), 3A7 and 4F2 [@Guengerich2021]. The cited paper here also provided quite a comprehensive background on the history of CYP450 and their relevance to toxicities in drugs, so I won't repeat them here.

<br>

###### **More on structural alerts**

More on ChEMBL structural alerts sets or filters - to explore what sort of data sources were used to build these structural alerts.

From ChEMBL 20, only 6 filters were present, as shown by this [ChEMBL blogpost](http://chembl.blogspot.com/2015/02/chembl-20-released.html) - it might appear that this blog post cited all 8 filters but in fact it only had 6.

* [Pfizer LINT filters](https://www.eurekaselect.com/article/24760)

* [Glaxo Wellcome hard filters](https://pubs.acs.org/doi/10.1021/ci990423o)

* [BMS HTS Deck Filters](https://pubs.acs.org/doi/10.1021/ci050504m)

* [NIH MLSMR Excluded Functionality Filters](https://www.yumpu.com/en/document/read/12367541/mlsmr-excluded-functionality-filters-nih-molecular-libraries-) (the old link provided in the old ChEMBL blog post was no longer available, this was found via [KNIME's REOS Tagger webpage](https://hub.knime.com/knime/spaces/Examples/00_Components/Life%20Sciences/REOS%20Tagger~bWMuzeSbFgbCrLWA/current-state))

* [University of Dundee NTD Screening Library Filters](https://chemistry-europe.onlinelibrary.wiley.com/doi/10.1002/cmdc.200700139) (also known as "Brenk filter" in RDKit)

* [PAINS filters](https://pubs.acs.org/doi/10.1021/jm901137j)

From ChEMBL 20 to 23, there were 8 filters in total (I also agreed with rd_filters' README.md that there weren't many documentations about this in ChEMBL, because I tried to search on ChEMBL but nothing in details were found - this might be useful if this could be added in the future), the sources of the two additional ones were as follow:

* Inpharmatica - unable to find direct source initially then I found out later that this was obtained through private communications between ChEMBL and Inpharmatica Ltd. in the earlier days as I went for more online searches (a bit of a convoluted process involving a few different key words...) and finally I came across an older ChEMBL presentation on ChEMBL 09 which mentioned about this, and also this was further elaborated by this paper [@chembl2017]

* [SureChEMBL](https://chembl.gitbook.io/surechembl/chemical-search/smarts-search) (old link provided by the paper [@chembl2017] also no longer exists)

RDKit (["Filtering unwanted substructures"](https://www.rdkit.org/docs/GettingStartedInPython.html#filtering-unwanted-substructures)) also has another NIH filter based on two other references - https://pubs.acs.org/doi/abs/10.1021/jm901070c and https://pubs.rsc.org/en/content/articlehtml/2015/ob/c4ob02287d#fn1. At one point I was so confused with this NIH filter here and the NIH MLSMR filter above... I thought they were the same but when I looked further they cited different reference papers. 

RDKit also uses the above 8 filters mentioned in ChEMBL in its [FilterCatalogs](https://www.rdkit.org/docs/source/rdkit.Chem.rdfiltercatalog.html#rdkit.Chem.rdfiltercatalog.FilterCatalogParams.FilterCatalogs) class. Brenk filter seems to be the same as the CHEMBL_Dundee one since both of them quoted the same journal paper as reference. It's also got a ZINC one I think. 

I also think I should stop looking at every structural alerts journal papers in this world as there are many...

<br>

###### **More on CYPs and ADMET**

A bit of a side-track as I came across a new paper online recently about using deep learning model for ADMET prediction and the data source used by this paper was from Therapeutics data commons (TDC). So while I'm working on this relevant topic of CYP, metabolism and toxicology of the ADMET, I thought to dig a bit deeper to see what sort of data were used by this group.

Re. [TDC ADME dataset](https://tdcommons.ai/single_pred_tasks/adme/#metabolism), specifically the metabolism one on all five CYP isoenzymes, were all derived from a 2009 paper by [Veith et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2783980/). I thought to have a closer look at the paper and also wanted to see if there were any detailed lists of molecules used in their *in vitro* testings. However, there were only mentions of,

"...we tested 17,143 samples at between seven and fifteen concentrations for all five CYP isozymes. The samples consisted of 8,019 compounds from the MLSMR including compounds chosen for diversity and rule-of-five compliance, 16 synthetic tractability, and availability; 6,144 compounds from a set of biofocused libraries which included 1,114 FDA-approved drugs; and 2,980 compounds from combinatorial libraries containing privileged structures targeted at GPCRs and kinases, and libraries of purified natural products or related structures...". 

If I went to its original journal paper site (the link provided was a NCBI one), there was only one additional Excel file with a long list of chemical scaffolds showing different CYP activities. So from the perspective of looking at approved drugs only, what I'm trying to do here might be interesting since I'm only planning to look at approved drugs only and this referenece paper used a mixture of diverse sets of molecules that were not all approved drugs. The only likely lists of compounds tested were shown in its figures 6 and 7, where figure 7 was more relevant for drug-drug interactions (not the goal of this post really). I then realised the ratio of FDA-approved drugs to the rest of the molecules tested in this paper was also not very balanced, and noticed that what they were saying in its discussion about how they were not noticing the usual prominent activities of CYP3A4 and 2D6 in the compounds they've tested, 

"...It has been suggested that CYP 3A4 is the most prominent P450 isozyme in drug metabolism and hepatic distribution (Fig. 2b),25, 26 but the drugs in our collection do not appear to have been optimized away from this activity. There has also been speculation that CYP 2D6 isozyme plays a prominent role in drug metabolism,27 but no difference in activity was observed between diversity compounds and approved drugs for this isozyme..."

Well, it might be due to the imbalanced set of compounds used e.g. number of FDA-approved drug (smaller) vs. number of other compounds from other libraries (larger!).

I also went to FDA's website to look at how the CYP stories were compiled. Here's the FDA link: https://www.fda.gov/drugs/drug-interactions-labeling/drug-development-and-drug-interactions-table-substrates-inhibitors-and-inducers. I've also noticed that *in vitro* inhibitors and clinical index inhibitors might not be completely the same across the CYPs. There were some overlappings in CYP3A4/5 and 2D6 for sure but definitely not exactly the same across all the documented CYP isoenzymes in the FDA webpage. 

So back to this new paper on predicting ADMET... how likely will it be useful in real-life drug-lead ADMET optimisation projects in drug discovery settings if the data source only involved a larger portion of non-approved drugs versus a smaller proportion of actual FDA-approved drugs? 

<br>

##### **Extracting data**

It's time to do some coding.

```{python}
import pandas as pd
import chembl_downloader
from chembl_downloader import latest
from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem.Draw import IPythonConsole
# For maximum common substructures
from rdkit.Chem import rdFMCS
# Label stereocentres
from rdkit.Chem import rdCIPLabeler
IPythonConsole.drawOptions.addAtomIndices = False
# Change to false to remove stereochem labels
IPythonConsole.drawOptions.addStereoAnnotation = True
IPythonConsole.ipython_useSVG=True
```

```{python}
# Latest version of ChEMBL
latest_version = latest()
print(f"The latest ChEMBL version is: {latest_version}")
```

I'm using SQL via chembl_downloader again to download approved drugs with their ChEMBL ID and equivalent canonical SMILES. All of the CYP3A4 inhibitors extracted from ChEMBL are based on the [Flockhart table of drug interactions](https://drug-interactions.medicine.iu.edu/MainTable.aspx) [@Flockhart2021].

Note: Three other categories of medicines are not going to be looked at currently, which are the weak inhibitors, ones with in vitro evidence only and ones that are still pending reviews.

A bit about retrieving data here, the following might not be the best way to get the data, but I've somehow incorporated chembl_downloader into my own small piece of function code to retrieve SMILES of approved drugs. Earlier on, I was repeating SQL queries and thought to improve them by using a function code instead - see Python script named as "cyp_drugs.py". It removes a large chunk of SQL query string every time when trying to get different CYP inhibitors, leaving only approved drug names so it's easier to read and understand.

Another possible way is to use get_target_sql(), e.g. using a specific CYP enzyme as the protein target to retrieve data, but it appears that there are no clear data marked to indicate the potency of CYP inhibition or induction (i.e. weak, moderate or strong) in the ChEMBL database (an example link for CYP2D6 in ChEMBL - https://www.ebi.ac.uk/chembl/web_components/explore/activities/STATE_ID:pxs_ydUxNelxmAa9ckYEPw%3D%3D). The Flockhart table has clearly annotated each approved drug with journal paper citations, so I'm going to stick with the following method for now.

```{python}
## Main issue previously was with sql string - too many quotation marks!
# e.g. WHERE molecule_dictionary.pref_name = '('KETOCONAZOLE', 'FLUCONAZOLE')'': near "KETOCONAZOLE": syntax error
# Resolved by adding string methods e.g. strip() and replace() to sql query string
# function code used chembl_downloader code as reference since it has no particular function to select drugs this way yet
from cyp_drugs import chembl_drugs

# Get a list of strong cyp3a4 inhibitors
# For the story on why I also added a weird spelling of "itraconzole", please see below.

# and save as a tsv file
df_3a4_strong_inh = chembl_drugs(
    "CERITINIB", "CLARITHROMYCIN", "DELAVIRIDINE", "IDELALISIB", "INDINAVIR", "ITRACONAZOLE", "ITRACONZOLE", "KETOCONAZOLE", "MIBEFRADIL", "NEFAZODONE", "NELFINAVIR", "RIBOCICLIB", "RITONAVIR", "SAQUINAVIR", "TELAPREVIR", "TELITHROMYCIN", "TUCATINIB", "VORICONAZOLE",
    #file_name="strong_3a4_inh"
    )
df_3a4_strong_inh
```

```{python}
## Get a list of moderate cyp3a4 inhibitors
# skipping grapefruit juice as it's not quite an approved drug...
# note: amlodipine inhibits cyp3a5
df_3a4_mod_inh = chembl_drugs(
    "AMLODIPINE", "APREPITANT", "CIPROFLOXACIN", "CRIZOTINIB", "DILTIAZEM", "ERYTHROMYCIN", "FLUCONAZOLE", "IMATINIB", "LETERMOVIR", "NETUPITANT", "VERAPAMIL", #file_name="mod_3a4_inh"
    )
df_3a4_mod_inh
```

```{python}
# Get a list of strong cyp2d6 inhibitors
df_2d6_strong_inh = chembl_drugs(
    "BUPROPION", "FLUOXETINE", "PAROXETINE", "QUINIDINE", 
    #file_name="strong_2d6_inh"
    )
df_2d6_strong_inh
```

```{python}
# Get a list of moderate cyp2d6 inhibitors
df_2d6_mod_inh = chembl_drugs(
    "ABIRATERONE", "CINACALCET", "CLOBAZAM", "DOXEPIN", "DULOXETINE", "HALOFANTRINE", "LORCASERIN", "MOCLOBEMIDE", "ROLAPITANT", "TERBINAFINE", 
    #file_name="mod_2d6_inh"
    )
df_2d6_mod_inh
```

Initially, four categories of approved drugs are retrieved - strong CYP3A4/5 inhibitors, moderate CYP3A4/5 inhibitors, strong CYP2D6 inhibitors and moderate CYP2D6 inhibitors.

This group of drugs inhibiting CYP3A4/5 is the largest cohort of all the cytochrome inhibitors. When a drug behaves like a cytochrome inhibitor, it inhibits the activity of a particular cytochrome enzyme e.g. CYP3A4 leading to a reduction of clearance of a particular therapeutic drug e.g. a CYP3A4 substrate such as apixaban, thus increasing its plasma concentration in vivo causing higher chance of adverse effect (which in the context of apixaban, this means the poor person who's taken apixaban may get excessive bleeding!).

<br>

##### **Import and preprocess data**

* Will look at the two largest group of CYP inhibitors first (may need to include substrates and inducers too - depends on how this will go...)

* Any interesting molecular motifs/substructures?

```{python}
## Tried using pandas 2.2.2, numpy 2.0.0 and rdkit 2024.3.1 (all latest major versions, note: rdkit has a latest minor release as 2024.03.4, which includes a patch for numpy 2.0)
# Seemed to work as a new df was generated but with some error messages shown though
# ---error message---
# A module that was compiled using NumPy 1.x cannot be run in
# NumPy 2.0.0 as it may crash. To support both 1.x and 2.x
# versions of NumPy, modules must be compiled with NumPy 2.0.
# Some module may need to rebuild instead e.g. with 'pybind11>=2.12'.
# If you are a user of the module, the easiest solution will be to
# downgrade to 'numpy<2' or try to upgrade the affected module.
# We expect that some modules will need time to support NumPy 2.


## used downgraded versions of pandas and numpy instead - confirmed that pandas 2.1.4, numpy 1.26.4 & rdkit 2024.3.1 worked with no error messages generated as output

# preprocess canonical smiles 
from mol_prep import preprocess

# cyp3a4 strong inhibitors
df_3a4_s_inh = df_3a4_strong_inh.copy()
df_3a4_s_inh_p = df_3a4_s_inh.apply(preprocess, axis=1)
df_3a4_s_inh_p.head(3)
```

```{python}
# cyp3a4 moderate inhibitors
df_3a4_m_inh = df_3a4_mod_inh.copy()
df_3a4_m_inh_p = df_3a4_m_inh.apply(preprocess, axis=1)
df_3a4_m_inh_p.head()
```

```{python}
# cyp2d6 strong inhibitors
df_2d6_s_inh = df_2d6_strong_inh.copy()
df_2d6_s_inh_p = df_2d6_s_inh.apply(preprocess, axis=1)
df_2d6_s_inh_p
```

```{python}
#cyp2d6 moderate inhibitors
df_2d6_m_inh = df_2d6_mod_inh.copy()
df_2d6_m_inh_p = df_2d6_m_inh.apply(preprocess, axis=1)
df_2d6_m_inh_p
```

##### **Images of structures**

* Checking structural validities

```{python}
# 2d6 mod inhibitors
image_2d6_m_inh = Draw.MolsToGridImage(df_2d6_m_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(250, 250), legends=list(df_2d6_m_inh_p["pref_name"]))
image_2d6_m_inh
```


```{python}
# 2d6 strong inhibitors
image_2d6_s_inh = Draw.MolsToGridImage(df_2d6_s_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(250, 250), legends=list(df_2d6_s_inh_p["pref_name"]))
image_2d6_s_inh
```

<br>

###### **Looking into duplicated structures and stereochemistries**

I have a feeling looking into stereochemistries might not be needed for now but as a fun exercise, I should, so below is a small section on looking at two drugs more closely along with their stereochemistries.

<br>

###### **quinidine**

Noted different stereochemistries between the two quinidines.

```{python}
# Some stereochemistries
# Older approach - AssignStereochemistry() -> this is used in datamol's standardize_mol()
# Newer approach - FindPotentialStereo()
```

```{python}
# Get 2D image of quinidine at row 3
df_2d6_s_inh_p.loc[3, "rdkit_mol"]
```

```{python}
# Get 2D image of quinidine at row 4
df_2d6_s_inh_p.loc[4, "rdkit_mol"]
```

```{python}
# Get SMILES for quinidine at row 3
df_2d6_s_inh_p.loc[3, "canonical_smiles"]
```

```{python}
# Get SMILES for quinidine at row 4
df_2d6_s_inh_p.loc[4, "canonical_smiles"]
```

```{python}
# quinidine at index row 3
quinidine_3 = Chem.MolFromSmiles('C=C[C@H]1CN2CCC1C[C@@H]2[C@@H](O)c1ccnc2ccc(OC)cc12')
rdCIPLabeler.AssignCIPLabels(quinidine_3)
quinidine_3
```

Ref: Stereochemical or CIP (Cahn–Ingold–Prelog) labeller in RDKit - https://rdkit.org/docs/source/rdkit.Chem.rdCIPLabeler.html#module-rdkit.Chem.rdCIPLabeler

```{python}
# quinidine index row 4
quinidine_4 = Chem.MolFromSmiles('C=C[C@H]1CN2CC[C@H]1C[C@@H]2[C@@H](O)c1ccnc2ccc(OC)cc12')
rdCIPLabeler.AssignCIPLabels(quinidine_4)
quinidine_4
```

Quinidine has 4 defined atom stereocentre count as per PubChem compound summary (as one of possible references for cross-checking) - https://pubchem.ncbi.nlm.nih.gov/compound/441074#section=Computed-Properties&fullscreen=true -> this is calculated on CHEMBL1294, which is the same as the quinidine spotted at index row 4!

Dropping the quinidine at index row 3 for now.

```{python}
# Note: old index unchanged for now (?need to re-index)
df_2d6_s_inh_p = df_2d6_s_inh_p.drop(labels = 3)
df_2d6_s_inh_p
```

<br>

###### **itraconazole**

Two itraconazoles to check for stereochemistries.

```{python}
df_3a4_s_inh_p.head()
```

```{python}
# 3a4 strong inhibitors
image_3a4_s_inh = Draw.MolsToGridImage(df_3a4_s_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(250, 250), legends=list(df_3a4_s_inh_p["pref_name"]))
image_3a4_s_inh
```

```{python}
# Get SMILES of itraconazole at index row 4
df_3a4_s_inh_p.loc[4, "canonical_smiles"]
```

```{python}
# Get SMILES of itraconazole at index row 5
df_3a4_s_inh_p.loc[5, "canonical_smiles"]
```

```{python}
itracon_4 = Chem.MolFromSmiles("CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OC[C@H]5CO[C@](Cn6cncn6)(c6ccc(Cl)cc6Cl)O5)cc4)CC3)cc2)c1=O")
rdCIPLabeler.AssignCIPLabels(itracon_4)
itracon_4
```

```{python}
itracon_5 = Chem.MolFromSmiles("CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OCC5COC(Cn6cncn6)(c6ccc(Cl)cc6Cl)O5)cc4)CC3)cc2)c1=O")
rdCIPLabeler.AssignCIPLabels(itracon_5)
itracon_5
```

Clearly, even if the SMILES of these two itraconzoles have not been converted into RDKit molecules, we can probably tell one of them has stereochemistries and the other molecule is without, due to the presence of "@" in the SMILES string for the one at index row 4. So the output images have shown exactly that - one with chiral centres, where the other does not have any.

PubChem calculations have different result for itraconazole. It seems it only has one defined atom stereocentre count and two undefined stereocentre counts. Ref: https://pubchem.ncbi.nlm.nih.gov/compound/44428219#section=Computed-Properties&fullscreen=true

Noted that the two itraconzoles obtained using the cyp_drug.py from ChEMBL have different ChEMBL ID numbers (ChEMBL ID: CHEMBL22587 and CHEMBL64391) to the one calculated in PubChem (ChEMBL ID: CHEMBL224725). So below I've looked into CHEMBL224725 first.

```{python}
# canonical smiles of another itraconzole ChEMBL ID as CHEMBL224725
# CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OC[C@H]5COC(Cn6cncn6)(c6ccc(F)cc6F)O5)cc4)CC3)cc2)c1=O

# itracon_x = Chem.MolFromSmiles("CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OC[C@H]5COC(Cn6cncn6)(c6ccc(F)cc6F)O5)cc4)CC3)cc2)c1=O")
# rdCIPLabeler.AssignCIPLabels(itracon_x)
# itracon_x

# note itracon_x = itracon_6 (later added)
```

Well, I've just found out a very strange thing in ChEMBL database, which was if I searched for "itraconazole" directly into the search field, only four entries appeared with ChEMBL IDs such as CHEMBL64391, CHEMBL22587, CHEMBL882 and CHEMBL5090785, and there was no ChEMBL224725. Then I noticed something that might be causing this discrepancy - a spelling error (which was most likely a typo by accident) of itraconazole as "itraconzole", which was actually carried over into PubChem as well. I did double check to make sure both "itraconzole" and the usual itraconazole were referring to the same chemical structure. Here are some screenshots showing the typo. ![Screenshot of "itraconzole" in ChEMBL database](chembl_itracon.png) ![Screenshot of "itraconzole" in PubChem that was inherited from ChEMBL](pubchem_itracon.png) 

So to add this specially-spelled "itraconzole" into the dataframe, I literally added the wrongly-spelled "itraconzole" into the SQL query above when obtaining drug information through chembl_downloader.

```{python}
# new addition - "itraconzole"
df_3a4_s_inh_p.loc[6, "canonical_smiles"]
```

```{python}
# new addition - "itraconzole"
itracon_6 = Chem.MolFromSmiles("CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OC[C@H]5COC(Cn6cncn6)(c6ccc(F)cc6F)O5)cc4)CC3)cc2)c1=O")
rdCIPLabeler.AssignCIPLabels(itracon_6)
itracon_6
```

There was only one stereocentre for "itraconzole", which would match the CHEMBL224725 entry for "itraconzole" in PubChem. Well, without looking into other cross-referencing sources, and if only sticking with PubChem for now, then I'd opt for this CHEMBL224725 version of "itraconzole".

I've then gone back to check all 3 (stereochemically-)different versions of itraconazole and found that the RDKit stereochemical calculations of these 3 itraconazoles have all basically matched their equivalent PubChem computations for atom sterecentre counts.

[CHEMBL22587 - PubChem CID 55283](https://pubchem.ncbi.nlm.nih.gov/compound/55283#section=Computed-Properties&fullscreen=true) - 2 defined, 1 undefined atom stereocentre count 

```{python}
itracon_4
```

[CHEMBL64391 - PubChem CID 3793](https://pubchem.ncbi.nlm.nih.gov/compound/3793#section=Computed-Properties&fullscreen=true) - 0 defined, 3 undefined atom stereocentre count 

```{python}
itracon_5
```

[CHEMBL224725 - PubChem CID 44428219](https://pubchem.ncbi.nlm.nih.gov/compound/44428219#section=Computed-Properties&fullscreen=true) - 1 defined, 2 undefined atom stereocentre count

```{python}
itracon_6
```

Dataframe of df_3a4_s_inh_p containing 3 different itraconazoles was then updated below to remove two of the triplicated entries.

```{python}
# Original df of strong 3a4 inhibitors
df_3a4_s_inh_p
```

Keeping the one with max phase marked as 4.0 (the other two had "NaN" and had no relevant medical or therapeutic indication data documented in PubMed).

```{python}
# Note old index unchanged (?need to re-index)
# Dropping itraconazole at index rows 4 & 6
df_3a4_s_inh_p = df_3a4_s_inh_p.drop(labels = [4, 6])
df_3a4_s_inh_p
```

```{python}
# 3a4 moderate inhibitors
image_3a4_m_inh = Draw.MolsToGridImage(df_3a4_m_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(250, 250), legends=list(df_3a4_m_inh_p["pref_name"]))
image_3a4_m_inh
```

<br>

##### **Time for maximum common substructures**

There were 3 antifungals, 2 macrolides, about 5 antivirals and 4 kinase inhibitors (ceritinib, tucatinib, idelalisib, ribociclib) in this category of **strong 3A4 inhibitors**. Maximum common substructures might be interesting to look at in this group.

*May do this for all strong CYP3A4 mols first, then in separate smaller sections e.g. antifungals, macrolides, antivirals etc.*

Re. maximum common substructures:

* [FindMCS](https://rdkit.org/docs/source/rdkit.Chem.rdFMCS.html) is for 2 or more mols & returns single-fragment MCS - based on FMCS algorithm [@dalke2013]

* RascalMCES (maximum common edge substructures) is for 2 mols only & returns multi-fragment MCES. A [RDKit blog post](https://greglandrum.github.io/rdkit-blog/posts/2023-11-08-introducingrascalmces.html) by Dave Cosgrove talks about this in more details.

```{python}
## Re. MCS - time to learn the basics

## Below code example is from https://rdkit.org/docs/GettingStartedInPython.html#findmcs

## Use RDKit mols
# mol1 = Chem.MolFromSmiles("O=C(NCc1cc(OC)c(O)cc1)CCCC/C=C/C(C)C")
# mol2 = Chem.MolFromSmiles("CC(C)CCCCCC(=O)NCC1=CC(=C(C=C1)O)OC")
# mol3 = Chem.MolFromSmiles("c1(C=O)cc(OC)c(O)cc1")
# mols = [mol1,mol2,mol3]

## Find MCS in mols
# res=rdFMCS.FindMCS(mols)

## MCS result instance
# res
# <rdkit.Chem.rdFMCS.MCSResult object at 0x...>

# Get images of highlighted MCS
# MolsToGridImage(mols, subImgSize=(300, 200), highlightAtomLists=[m.GetSubstructMatch(res.queryMol) for m in mols])

## Number of atoms in MCS
# res.numAtoms
# 10

## Number of bonds in MCS
# res.numBonds
# 10

## The SMARTS string that matches the found MCS
# res.smartsString
# '[#6]1(-[#6]):[#6]:[#6](-[#8]-[#6]):[#6](:[#6]:[#6]:1)-[#8]'

# res.canceled
# False
```

```{python}
## Get list of RDKit mols
mols = list(df_3a4_s_inh_p["rdkit_mol"])
#mols

## Find MCS in mols
s_3a4_mcs=rdFMCS.FindMCS(mols)

## MCS result instance
s_3a4_mcs
```

```{python}
# Get images of highlighted MCS for strong CYP3A4 inhibitors
Draw.MolsToGridImage(mols, subImgSize=(500, 400), molsPerRow=2, legends = list(df_3a4_s_inh_p["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(s_3a4_mcs.queryMol) for m in mols])
```

```{python}
## Number of atoms in MCS
s_3a4_mcs.numAtoms
```

```{python}
## Number of bonds in MCS
s_3a4_mcs.numBonds
```

```{python}
## The SMARTS string that matches the found MCS
s_3a4_mcs.smartsString
```

Two interesting blog posts on RDKit's MCS:

* https://projects.volkamerlab.org/teachopencadd/talktorials/T006_compound_maximum_common_substructures.html - a nice tutorial-like piece that is good for learning as it introduces and explains about the MCS and FMCS algorithm

* https://www.blopig.com/blog/2023/06/customising-mcs-mapping-in-rdkit/

```{python}
# reducing threshold to relax MCS rule - to see how MCS changes
s_3a4_mcs_80=rdFMCS.FindMCS(mols, threshold=0.8)
Draw.MolsToGridImage(mols, subImgSize=(500, 400), molsPerRow=2, legends = list(df_3a4_s_inh_p["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(s_3a4_mcs_80.queryMol) for m in mols])
```

```{python}
# Without changing threshold
s_3a4_mcs1 = Chem.MolFromSmarts(s_3a4_mcs.smartsString)

# Lowered threshold to 80% of mols
s_3a4_mcs2 = Chem.MolFromSmarts(s_3a4_mcs_80.smartsString)
```

```{python}
Draw.MolsToGridImage([s_3a4_mcs1, s_3a4_mcs2], legends=["MCS1", "MCS2: threshold = 0.8"])
```

?Add in moderate CYP3A4 inhibitors to see if MCS changes (as above only on strong 3A4 inhibitors)

Check MCS for each different class of drugs e.g. antivirals, antifungals, macrolides... etc.


```{python}
# matching ring bonds (if any)


```


```{python}
## Reference code borrowed from https://gist.github.com/iwatobipen/6d8708d8c77c615cfffbb89409be730d by iwatobipen

# from rdkit import Chem
# from rdkit.Chem import Draw
#from rdkit.Chem.Draw import IPythonConsole
# from rdkit.Chem import rdFMCS
# from rdkit.Chem.Draw import rdDepictor
# rdDepictor.SetPreferCoordGen(True)
# IPythonConsole.drawOptions.minFontSize=20

# def view_difference(mol1, mol2):
#     mcs = rdFMCS.FindMCS([mol1,mol2])
#     mcs_mol = Chem.MolFromSmarts(mcs.smartsString)
#     match1 = mol1.GetSubstructMatch(mcs_mol)
#     target_atm1 = []
#     for atom in mol1.GetAtoms():
#         if atom.GetIdx() not in match1:
#             target_atm1.append(atom.GetIdx())
#     match2 = mol2.GetSubstructMatch(mcs_mol)
#     target_atm2 = []
#     for atom in mol2.GetAtoms():
#         if atom.GetIdx() not in match2:
#             target_atm2.append(atom.GetIdx())
#     return Draw.MolsToGridImage([mol1, mol2],highlightAtomLists=[target_atm1, target_atm2])
```

```{python}
# There's also another example from RDKit blog post re. "New MCS features in 2023.09.1" - went into more details and new features etc.


```





Future posts may involve looking at other CYPs, particularly on other inhibitors and substrates. Inducers are a different story as they tend to increase drug metabolisms via CYP inductions, which are more likely to do with losing therapeutic effects than gaining adverse effects.