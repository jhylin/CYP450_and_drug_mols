---
title: "Cytochrome P450 (CYP) and small drug molecules"
subtitle: "CYP3A4 and 2D6 inhibitors"
author: Jennifer HY Lin
date: '2024-8-1'
draft: true
categories: 
    - Metabolism
    - Toxicology
    - Structural alerts
    - Pandas
    - RDKit
    - ChEMBL database
    - Python
jupyter: python3
format: html
bibliography: references.bib
---

##### **Some introductions**

I initially wanted to work on something about drug toxicology without setting any goals or intentions on how this post would end (basically doing this as a free-style post) and currently I felt it would be more to do with metabolism, which was also directly linked to drug toxicity, an important area not to ignore during any therapeutic drug discovery and developmental work.

This post was sort of inspired by a recent commentary that talked about "avoidome" and DMPK-related proteins to avoid [@Fraser2024]. I also happened to encounter two other blog posts ([a post from D. Lowe](https://www.science.org/content/blog-post/john-keats-would-word), and [another one from P. Kenny](https://fbdd-lit.blogspot.com/2024/03/)) that have provided reviews on this commentary recently with interesting view points.

In a very rough sense, three main areas have been looked at (not exhaustive) with the aim to create safer therapeutic drugs: 

1. **Structural alerts** on compound substructures that were known to cause adverse drug effects or pan-assay interference compounds (PAINs)

    Many have looked into structural alerts (an example repo: [rd_filters](https://github.com/PatWalters/rd_filters)). ChEMBL database has already had a cheminformatic utils web service developed that provided structural alert computations for compounds. There were most likely much more efforts than these ones.

2. Toxicophores in relation to **human ether-a-go-go-related gene (hERG) potassium channel** (this might be similar to the first one actually)

    hERG potassium channel was also another frequently-looked-at aspect for drug toxicology due to its known effect leading to cardiac QT prolongations or more commonly known as arrhythmias [@Curran1995].

3. **Cytochrome P450 enzymes** (CYP450, CYP isoenzymes, CYP or CYPs), the well-known ones were CYP3A4, 2D6, 1A2, 2C9 and 2C19

    CYP450 enzymes played a key role in the metabolism and toxicology parts of the ADMET process of drugs, all I wanted to do was to look into the relationship between CYP450 and small drug molecules to see if there was anything interesting for further explorations. This post would start with the two largest groups of CYP inhibitors, so focussing on CYP3A4 and 2D6 first.

Other useful categories involved drug-induced skin sensitisations and liver injuries and more.

While my focus was only on a very small cohort of small molecules relating to only two CYPs, it was also worth noting that there were actually more CYPs present as well, for example, CYP1A1, 2A6, 2B6, 2C8, 2E1, 2J2, 3A5 (note: amlodipine was a moderate CYP3A5 inhibitor and would be looked at below), 3A7 and 4F2 [@Guengerich2021]. The cited paper here also provided quite a comprehensive background on the history of CYP450 and their relevance to toxicities in drugs, so I won't repeat them here.

<br>

###### **More on structural alerts**

More on ChEMBL structural alerts sets or filters - to explore what sort of data sources were used to build these structural alerts.

From ChEMBL 20, only 6 filters were present, as shown by this [ChEMBL blogpost](http://chembl.blogspot.com/2015/02/chembl-20-released.html) - it might appear that this blog post cited all 8 filters but in fact it only had 6.

* [Pfizer LINT filters](https://www.eurekaselect.com/article/24760)

* [Glaxo Wellcome hard filters](https://pubs.acs.org/doi/10.1021/ci990423o)

* [BMS HTS Deck Filters](https://pubs.acs.org/doi/10.1021/ci050504m)

* [NIH MLSMR Excluded Functionality Filters](https://www.yumpu.com/en/document/read/12367541/mlsmr-excluded-functionality-filters-nih-molecular-libraries-) (the old link provided in the old ChEMBL blog post was no longer available, this was found via [KNIME's REOS Tagger webpage](https://hub.knime.com/knime/spaces/Examples/00_Components/Life%20Sciences/REOS%20Tagger~bWMuzeSbFgbCrLWA/current-state))

* [University of Dundee NTD Screening Library Filters](https://chemistry-europe.onlinelibrary.wiley.com/doi/10.1002/cmdc.200700139) (also known as "Brenk filter" in RDKit)

* [PAINS filters](https://pubs.acs.org/doi/10.1021/jm901137j)

From ChEMBL 20 to 23, there were 8 filters in total (I also agreed with rd_filters' README.md that there weren't many documentations about this in ChEMBL, because I tried to search on ChEMBL but nothing in details were found - this might be useful if this could be added in the future), the sources of the two additional ones were as follow:

* Inpharmatica - unable to find direct source initially then I found out later that this was obtained through private communications between ChEMBL and Inpharmatica Ltd. in the earlier days as I went for more online searches (a bit of a convoluted process involving a few different key words...) and finally I came across an older ChEMBL presentation on ChEMBL 09 which mentioned about this, and also this was further elaborated by this paper [@chembl2017]

* [SureChEMBL](https://chembl.gitbook.io/surechembl/chemical-search/smarts-search) (old link provided by the paper [@chembl2017] also no longer exists)

RDKit (["Filtering unwanted substructures"](https://www.rdkit.org/docs/GettingStartedInPython.html#filtering-unwanted-substructures)) also has another NIH filter based on two other references [@Jadhav2010] and [@Doveston2015]. At one point I was so confused with this NIH filter here and the NIH MLSMR filter above... I thought they were the same but when I looked further they cited different reference papers. 

RDKit also uses the above 8 filters mentioned in ChEMBL in its [FilterCatalogs](https://www.rdkit.org/docs/source/rdkit.Chem.rdfiltercatalog.html#rdkit.Chem.rdfiltercatalog.FilterCatalogParams.FilterCatalogs) class. Brenk filter seems to be the same as the CHEMBL_Dundee one since both of them quoted the same journal paper as reference. It's also got a ZINC one I think. 

I also think I should stop looking at every structural alerts journal papers in this world as there are many...

<br>

###### **More on CYPs and ADMET**

A bit of a sidetrack as I came across a new paper online recently about using deep learning model for ADMET prediction and the data source used by this paper was from Therapeutics data commons (TDC). So while I'm working on this relevant topic of CYP, metabolism and toxicology of the ADMET, I thought to dig a bit deeper to see what sort of data were used by TDC.

The [TDC ADME dataset](https://tdcommons.ai/single_pred_tasks/adme/#metabolism), specifically the metabolism one on all five CYP isoenzymes (CYP2C19, 2D6, 3A4, 1A2 and 2C9), were all derived from a 2009 paper by [Veith et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2783980/). I just wanted to have a closer look at this paper to see if there were any detailed lists of molecules used in their *in vitro* testings, but unfortunately (unless I missed something there...), it seemed there were only mentions of:

> ...we tested 17,143 samples at between seven and fifteen concentrations for all five CYP isozymes. The samples consisted of 8,019 compounds from the MLSMR including compounds chosen for diversity and rule-of-five compliance, 16 synthetic tractability, and availability; 6,144 compounds from a set of biofocused libraries which included 1,114 FDA-approved drugs; and 2,980 compounds from combinatorial libraries containing privileged structures targeted at GPCRs and kinases, and libraries of purified natural products or related structures...

If I went to its original journal paper site (the link provided was a NCBI one), there was only one additional Excel file with a long list of chemical scaffolds showing different CYP activities (no other supplementary information I could spot there). The only likely lists of compounds tested were shown in its figures 6 and 7 in the paper, where figure 7 was more relevant for drug-drug interactions. I then realised the proportions of FDA-approved drugs used and the rest of the molecules tested in this paper were also not very balanced (thinking along the line of approved drugs and non-approved drugs), and noticed that what they were saying in its discussion about how they were not noticing the usual prominent activities of CYP3A4 and 2D6 in the compounds they've tested:

> ...It has been suggested that CYP 3A4 is the most prominent P450 isozyme in drug metabolism and hepatic distribution (Fig. 2b),^25^^,^ ^26^ but the drugs in our collection do not appear to have been optimized away from this activity. There has also been speculation that CYP 2D6 isozyme plays a prominent role in drug metabolism,^27^ but no difference in activity was observed between diversity compounds and approved drugs for this isozyme...

Well, it might be due to the imbalanced set of compounds used e.g. number of FDA-approved drug (smaller) vs. number of other compounds from other libraries (larger).

I also went to FDA's website to look at how the CYP stories were compiled ([the FDA link](https://www.fda.gov/drugs/drug-interactions-labeling/drug-development-and-drug-interactions-table-substrates-inhibitors-and-inducers)). I've also noticed that *in vitro* inhibitors and clinical index inhibitors might not be completely the same across the CYPs. There were some overlappings in CYP3A4/5 and 2D6 for sure but definitely not exactly the same across all the documented CYP isoenzymes in the FDA webpage. 

So back to this new paper on predicting ADMET... how likely will it be useful in real-life hit/lead ADMET optimisation projects in drug discovery settings if the data source only involved a larger portion of non-approved drugs versus a smaller portion of actual FDA-approved drugs? It just shows that there were a lot of things to think about in the DMPK or ADMET areas in drug design or discovery pipelines, as ultimately this is crucial to see if a candidate molecule will proceed or not (i.e. causing toxicity or not and whether it's tolerable side effects or adverse and even life-threatening ones instead).

<br>

##### **Extracting data**

It's time to do some coding.

```{python}
import pandas as pd
import chembl_downloader
from chembl_downloader import latest
from rdkit import Chem
from rdkit.Chem import Draw, AllChem
# For maximum common substructures & labelling stereocentres
from rdkit.Chem import rdFMCS, rdCIPLabeler
from rdkit.Chem.Draw import IPythonConsole
IPythonConsole.drawOptions.addAtomIndices = False
# Change to false to remove stereochem labels
IPythonConsole.drawOptions.addStereoAnnotation = True
IPythonConsole.ipython_useSVG=True
```

```{python}
# Latest version of ChEMBL
latest_version = latest()
print(f"The latest ChEMBL version is: {latest_version}")
```

I'm using SQL via chembl_downloader again to download approved drugs with their ChEMBL ID and equivalent canonical SMILES. All of the CYP3A4 inhibitors extracted from ChEMBL are based on the [Flockhart table of drug interactions](https://drug-interactions.medicine.iu.edu/MainTable.aspx) [@Flockhart2021].

Note: Three other categories of medicines are not going to be looked at currently, which are the weak inhibitors, ones with in vitro evidence only and ones that are still pending reviews.

A bit about retrieving data here, the following might not be the best way to get the data, but I've somehow incorporated chembl_downloader into my own small piece of function code to retrieve SMILES of approved drugs. Earlier on, I was repeating SQL queries and thought to improve them by using a function code instead - see Python script named as "cyp_drugs.py". It removes a large chunk of SQL query string every time when trying to get different CYP inhibitors, leaving only approved drug names so it's easier to read and understand.

Another possible way is to use get_target_sql(), e.g. using a specific CYP enzyme as the protein target to retrieve data, but it appears that there are no clear data marked to indicate the potency of CYP inhibition or induction (i.e. weak, moderate or strong) in the ChEMBL database (an [example link for CYP2D6 in ChEMBL](https://www.ebi.ac.uk/chembl/web_components/explore/activities/STATE_ID:pxs_ydUxNelxmAa9ckYEPw%3D%3D)). The Flockhart table has clearly annotated each approved drug with journal paper citations, so I'm going to stick with the following method for now.

```{python}
## Main issue previously was with sql string - too many quotation marks!
# e.g. WHERE molecule_dictionary.pref_name = '('KETOCONAZOLE', 'FLUCONAZOLE')'': near "KETOCONAZOLE": syntax error
# Resolved by adding string methods e.g. strip() and replace() to sql query string
# function code used chembl_downloader code as reference since it has no particular function to select drugs this way yet
from cyp_drugs import chembl_drugs

# Get a list of strong cyp3a4 inhibitors
# For the story on why I also added a weird spelling of "itraconzole", please see below.

# and save as a tsv file
df_3a4_strong_inh = chembl_drugs(
    "CERITINIB", "CLARITHROMYCIN", "DELAVIRIDINE", "IDELALISIB", "INDINAVIR", "ITRACONAZOLE", "ITRACONZOLE", "KETOCONAZOLE", "MIBEFRADIL", "NEFAZODONE", "NELFINAVIR", "RIBOCICLIB", "RITONAVIR", "SAQUINAVIR", "TELAPREVIR", "TELITHROMYCIN", "TUCATINIB", "VORICONAZOLE",
    #file_name="strong_3a4_inh"
    )
df_3a4_strong_inh
```

```{python}
## Get a list of moderate cyp3a4 inhibitors
# skipping grapefruit juice as it's not quite an approved drug...
# note: amlodipine inhibits cyp3a5
df_3a4_mod_inh = chembl_drugs(
    "AMLODIPINE", "APREPITANT", "CIPROFLOXACIN", "CRIZOTINIB", "DILTIAZEM", "ERYTHROMYCIN", "FLUCONAZOLE", "IMATINIB", "LETERMOVIR", "NETUPITANT", "VERAPAMIL", #file_name="mod_3a4_inh"
    )
df_3a4_mod_inh
```

```{python}
# Get a list of strong cyp2d6 inhibitors
df_2d6_strong_inh = chembl_drugs(
    "BUPROPION", "FLUOXETINE", "PAROXETINE", "QUINIDINE", 
    #file_name="strong_2d6_inh"
    )
df_2d6_strong_inh
```

```{python}
# Get a list of moderate cyp2d6 inhibitors
df_2d6_mod_inh = chembl_drugs(
    "ABIRATERONE", "CINACALCET", "CLOBAZAM", "DOXEPIN", "DULOXETINE", "HALOFANTRINE", "LORCASERIN", "MOCLOBEMIDE", "ROLAPITANT", "TERBINAFINE", 
    #file_name="mod_2d6_inh"
    )
df_2d6_mod_inh
```

Initially, four categories of approved drugs are retrieved - strong CYP3A4/5 inhibitors, moderate CYP3A4/5 inhibitors, strong CYP2D6 inhibitors and moderate CYP2D6 inhibitors.

This group of drugs inhibiting CYP3A4/5 is the largest cohort of all the cytochrome inhibitors. When a drug behaves like a cytochrome inhibitor, it inhibits the activity of a particular cytochrome enzyme e.g. CYP3A4 leading to a reduction of clearance of a particular therapeutic drug e.g. a CYP3A4 substrate such as apixaban, thus increasing its plasma concentration in vivo causing higher chance of adverse effect (which in the context of apixaban, this means the poor person who's taken apixaban may get excessive bleeding!).

<br>

##### **Import and preprocess data**

* Any interesting molecular motifs/substructures?

```{python}
## Tried using pandas 2.2.2, numpy 2.0.0 and rdkit 2024.3.1 (all latest major versions, note: rdkit has a latest minor release as 2024.03.4, which includes a patch for numpy 2.0)
# Seemed to work as a new df was generated but with some error messages shown though
# ---error message---
# A module that was compiled using NumPy 1.x cannot be run in
# NumPy 2.0.0 as it may crash. To support both 1.x and 2.x
# versions of NumPy, modules must be compiled with NumPy 2.0.
# Some module may need to rebuild instead e.g. with 'pybind11>=2.12'.
# If you are a user of the module, the easiest solution will be to
# downgrade to 'numpy<2' or try to upgrade the affected module.
# We expect that some modules will need time to support NumPy 2.


## used downgraded versions of pandas and numpy instead - confirmed that pandas 2.1.4, numpy 1.26.4 & rdkit 2024.3.1 worked with no error messages generated as output

# preprocess canonical smiles 
from mol_prep import preprocess

# cyp3a4 strong inhibitors
df_3a4_s_inh = df_3a4_strong_inh.copy()
df_3a4_s_inh_p = df_3a4_s_inh.apply(preprocess, axis=1)
df_3a4_s_inh_p.head(3)
```

```{python}
# cyp3a4 moderate inhibitors
df_3a4_m_inh = df_3a4_mod_inh.copy()
df_3a4_m_inh_p = df_3a4_m_inh.apply(preprocess, axis=1)
df_3a4_m_inh_p.head()
```

```{python}
# cyp2d6 strong inhibitors
df_2d6_s_inh = df_2d6_strong_inh.copy()
df_2d6_s_inh_p = df_2d6_s_inh.apply(preprocess, axis=1)
df_2d6_s_inh_p
```

```{python}
#cyp2d6 moderate inhibitors
df_2d6_m_inh = df_2d6_mod_inh.copy()
df_2d6_m_inh_p = df_2d6_m_inh.apply(preprocess, axis=1)
df_2d6_m_inh_p
```

##### **Images of structures**

* Checking structural validities

```{python}
# 2d6 mod inhibitors
image_2d6_m_inh = Draw.MolsToGridImage(
    df_2d6_m_inh_p["rdkit_mol"], 
    molsPerRow=3, 
    subImgSize=(400, 300), 
    legends=list(df_2d6_m_inh_p["pref_name"])
    )
image_2d6_m_inh
```


```{python}
# 2d6 strong inhibitors
image_2d6_s_inh = Draw.MolsToGridImage(
    df_2d6_s_inh_p["rdkit_mol"], 
    molsPerRow=3, 
    subImgSize=(400, 300), 
    legends=list(df_2d6_s_inh_p["pref_name"])
    )
image_2d6_s_inh
```

<br>

###### **Looking into duplicated structures and stereochemistries**

I have a feeling looking into stereochemistries might not be needed for now but as a fun exercise, I should, so below is a small section on looking at two drugs more closely along with their stereochemistries.

<br>

###### **quinidine**

Noted different stereochemistries between the two quinidines.

```{python}
# Some stereochemistries
# Older approach - AssignStereochemistry() -> this is used in datamol's standardize_mol()
# Newer approach - FindPotentialStereo()
```

```{python}
# Get 2D image of quinidine at row 3
df_2d6_s_inh_p.loc[3, "rdkit_mol"]
```

```{python}
# Get 2D image of quinidine at row 4
df_2d6_s_inh_p.loc[4, "rdkit_mol"]
```

```{python}
# Get SMILES for quinidine at row 3
df_2d6_s_inh_p.loc[3, "canonical_smiles"]
```

```{python}
# Get SMILES for quinidine at row 4
df_2d6_s_inh_p.loc[4, "canonical_smiles"]
```

```{python}
# quinidine at index row 3
quinidine_3 = Chem.MolFromSmiles('C=C[C@H]1CN2CCC1C[C@@H]2[C@@H](O)c1ccnc2ccc(OC)cc12')
rdCIPLabeler.AssignCIPLabels(quinidine_3)
quinidine_3
```

Ref: Stereochemical or CIP (Cahn–Ingold–Prelog) labeller in RDKit - https://rdkit.org/docs/source/rdkit.Chem.rdCIPLabeler.html#module-rdkit.Chem.rdCIPLabeler

```{python}
# quinidine index row 4
quinidine_4 = Chem.MolFromSmiles('C=C[C@H]1CN2CC[C@H]1C[C@@H]2[C@@H](O)c1ccnc2ccc(OC)cc12')
rdCIPLabeler.AssignCIPLabels(quinidine_4)
quinidine_4
```

Quinidine has 4 defined atom stereocentre count as per PubChem compound summary (as one of possible references for cross-checking) - https://pubchem.ncbi.nlm.nih.gov/compound/441074#section=Computed-Properties&fullscreen=true -> this is calculated on CHEMBL1294, which is the same as the quinidine spotted at index row 4!

Dropping the quinidine at index row 3 for now.

```{python}
# Note: old index unchanged for now (?need to re-index)
df_2d6_s_inh_p = df_2d6_s_inh_p.drop(labels = 3)
df_2d6_s_inh_p
```

<br>

###### **itraconazole**

Two itraconazoles to check for stereochemistries.

```{python}
df_3a4_s_inh_p.head()
```

```{python}
# 3a4 strong inhibitors
image_3a4_s_inh = Draw.MolsToGridImage(df_3a4_s_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(400, 300), legends=list(df_3a4_s_inh_p["pref_name"]))
image_3a4_s_inh
```

```{python}
# Get SMILES of itraconazole at index row 4
df_3a4_s_inh_p.loc[4, "canonical_smiles"]
```

```{python}
# Get SMILES of itraconazole at index row 5
df_3a4_s_inh_p.loc[5, "canonical_smiles"]
```

```{python}
itracon_4 = Chem.MolFromSmiles("CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OC[C@H]5CO[C@](Cn6cncn6)(c6ccc(Cl)cc6Cl)O5)cc4)CC3)cc2)c1=O")
rdCIPLabeler.AssignCIPLabels(itracon_4)
itracon_4
```

```{python}
itracon_5 = Chem.MolFromSmiles("CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OCC5COC(Cn6cncn6)(c6ccc(Cl)cc6Cl)O5)cc4)CC3)cc2)c1=O")
rdCIPLabeler.AssignCIPLabels(itracon_5)
itracon_5
```

Clearly, even if the SMILES of these two itraconzoles have not been converted into RDKit molecules, we can probably tell one of them has stereochemistries and the other molecule is without, due to the presence of "@" in the SMILES string for the one at index row 4. So the output images have shown exactly that - one with chiral centres, where the other does not have any.

PubChem calculations have different result for itraconazole. It seems it only has one defined atom stereocentre count and two undefined stereocentre counts ([PubChem reference](https://pubchem.ncbi.nlm.nih.gov/compound/44428219#section=Computed-Properties&fullscreen=true)).

Noted that the two itraconzoles obtained using the cyp_drug.py from ChEMBL have different ChEMBL ID numbers (ChEMBL ID: CHEMBL22587 and CHEMBL64391) to the one calculated in PubChem (ChEMBL ID: CHEMBL224725). So below I've looked into CHEMBL224725 first.

```{python}
# canonical smiles of another itraconzole ChEMBL ID as CHEMBL224725
# CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OC[C@H]5COC(Cn6cncn6)(c6ccc(F)cc6F)O5)cc4)CC3)cc2)c1=O

# itracon_x = Chem.MolFromSmiles("CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OC[C@H]5COC(Cn6cncn6)(c6ccc(F)cc6F)O5)cc4)CC3)cc2)c1=O")
# rdCIPLabeler.AssignCIPLabels(itracon_x)
# itracon_x

# note itracon_x = itracon_6 (later added)
```

Well, I've just found out a very strange thing in ChEMBL database, which was if I searched for "itraconazole" directly into the search field, only four entries appeared with ChEMBL IDs such as CHEMBL64391, CHEMBL22587, CHEMBL882 and CHEMBL5090785, and there was no ChEMBL224725. Then I noticed something that might be causing this discrepancy - a spelling error (which was most likely a typo by accident) of itraconazole as "itraconzole", which was actually carried over into PubChem as well. I did double check to make sure both "itraconzole" and the usual itraconazole were referring to the same chemical structure. Here are some screenshots showing the typo. ![Screenshot of "itraconzole" in ChEMBL database](chembl_itracon.png) ![Screenshot of "itraconzole" in PubChem that was inherited from ChEMBL](pubchem_itracon.png) 

So to add this specially-spelled "itraconzole" into the dataframe, I literally added the wrongly-spelled "itraconzole" into the SQL query above when obtaining drug information through chembl_downloader.

```{python}
# new addition - "itraconzole"
df_3a4_s_inh_p.loc[6, "canonical_smiles"]
```

```{python}
# new addition - "itraconzole"
itracon_6 = Chem.MolFromSmiles("CCC(C)n1ncn(-c2ccc(N3CCN(c4ccc(OC[C@H]5COC(Cn6cncn6)(c6ccc(F)cc6F)O5)cc4)CC3)cc2)c1=O")
rdCIPLabeler.AssignCIPLabels(itracon_6)
itracon_6
```

There was only one stereocentre for "itraconzole", which would match the CHEMBL224725 entry for "itraconzole" in PubChem. Well, without looking into other cross-referencing sources, and if only sticking with PubChem for now, I've then gone back to check all 3 (stereochemically-)different versions of itraconazole and found that the RDKit stereochemical calculations of these 3 itraconazoles have all basically matched their equivalent PubChem computations for atom sterecentre counts.

[CHEMBL22587 - PubChem CID 55283](https://pubchem.ncbi.nlm.nih.gov/compound/55283#section=Computed-Properties&fullscreen=true) - 2 defined, 1 undefined atom stereocentre count 

```{python}
itracon_4
```

[CHEMBL64391 - PubChem CID 3793](https://pubchem.ncbi.nlm.nih.gov/compound/3793#section=Computed-Properties&fullscreen=true) - 0 defined, 3 undefined atom stereocentre count 

```{python}
itracon_5
```

[CHEMBL224725 - PubChem CID 44428219](https://pubchem.ncbi.nlm.nih.gov/compound/44428219#section=Computed-Properties&fullscreen=true) - 1 defined, 2 undefined atom stereocentre count

```{python}
itracon_6
```

Dataframe of df_3a4_s_inh_p containing 3 different itraconazoles was then updated below to remove two of the triplicated entries.

```{python}
# Original df of strong 3a4 inhibitors
df_3a4_s_inh_p
```

Keeping the one with max phase marked as 4.0 (the other two had "NaN" and had no relevant medical or therapeutic indications data documented in PubMed).

```{python}
# Note old index unchanged (?need to re-index)
# Dropping itraconazole at index rows 4 & 6
df_3a4_s_inh_p = df_3a4_s_inh_p.drop(labels = [4, 6])
df_3a4_s_inh_p
```

```{python}
# 3a4 moderate inhibitors
image_3a4_m_inh = Draw.MolsToGridImage(
    df_3a4_m_inh_p["rdkit_mol"], 
    molsPerRow=3, 
    subImgSize=(400, 300), 
    legends=list(df_3a4_m_inh_p["pref_name"])
    )
image_3a4_m_inh
```

<br>

##### **Maximum common substructures**

Maximum common substructures (MCS) might be interesting to look at in this group.

Re. MCS in RDKit:

* [FindMCS](https://rdkit.org/docs/source/rdkit.Chem.rdFMCS.html) is for 2 or more mols and returns single-fragment MCS - based on FMCS algorithm [@dalke2013]

* RascalMCES (maximum common edge substructures) is for 2 mols only and returns multi-fragment MCES. A [RDKit blog post](https://greglandrum.github.io/rdkit-blog/posts/2023-11-08-introducingrascalmces.html) by Dave Cosgrove talks about this in more details

```{python}
# ?Add code fold

## Below code example is from https://rdkit.org/docs/GettingStartedInPython.html#findmcs
## Use RDKit mols
# mol1 = Chem.MolFromSmiles("O=C(NCc1cc(OC)c(O)cc1)CCCC/C=C/C(C)C")
# mol2 = Chem.MolFromSmiles("CC(C)CCCCCC(=O)NCC1=CC(=C(C=C1)O)OC")
# mol3 = Chem.MolFromSmiles("c1(C=O)cc(OC)c(O)cc1")
# mols = [mol1,mol2,mol3]

## Find MCS in mols
# res=rdFMCS.FindMCS(mols)

## MCS result instance
# res
# <rdkit.Chem.rdFMCS.MCSResult object at 0x...>

# Get images of highlighted MCS
# MolsToGridImage(mols, subImgSize=(300, 200), highlightAtomLists=[m.GetSubstructMatch(res.queryMol) for m in mols])

## Number of atoms in MCS
# res.numAtoms
# 10

## Number of bonds in MCS
# res.numBonds
# 10

## The SMARTS string that matches the found MCS
# res.smartsString
# '[#6]1(-[#6]):[#6]:[#6](-[#8]-[#6]):[#6](:[#6]:[#6]:1)-[#8]'

# res.canceled
# False
```

Two other interesting blog posts on RDKit's MCS:

* [https://projects.volkamerlab.org/teachopencadd/talktorials/T006_compound_maximum_common_substructures.html](https://projects.volkamerlab.org/teachopencadd/talktorials/T006_compound_maximum_common_substructures.html) - a nice tutorial-like piece that is good for learning as it introduces and explains about the MCS and FMCS algorithm

* [https://www.blopig.com/blog/2023/06/customising-mcs-mapping-in-rdkit/](https://www.blopig.com/blog/2023/06/customising-mcs-mapping-in-rdkit/) - a more detailed post providing code examples about atom matching

<br>

###### **Strong CYP3A4 inhibitors**

```{python}
# Get list of RDKit mols
mols_s3a4 = list(df_3a4_s_inh_p["rdkit_mol"])

# Find MCS in mols
s3a4_mcs = rdFMCS.FindMCS(mols_s3a4)

# MCS result instance
# s3a4_mcs

# Get images of highlighted MCS for strong CYP3A4 inhibitors
Draw.MolsToGridImage(
    mols_s3a4, 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_3a4_s_inh_p["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(s3a4_mcs.queryMol) for m in mols_s3a4]
    )
```

```{python}
## Number of atoms and bonds in MCS
s3a4_mcs.numAtoms, s3a4_mcs.numBonds
```

```{python}
## The SMARTS string that matches the found MCS
s3a4_mcs.smartsString
```

Reducing threshold to relax MCS rule - to see how MCS changes:

```{python}
s3a4_mcs_80=rdFMCS.FindMCS(mols_s3a4, threshold=0.8)

Draw.MolsToGridImage(
    mols_s3a4, 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_3a4_s_inh_p["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(s3a4_mcs_80.queryMol) for m in mols_s3a4]
    )
```

```{python}
# Without changing threshold
s3a4_mcs1 = Chem.MolFromSmarts(s3a4_mcs.smartsString)

# Lowered MCS threshold to 80% of mols
s3a4_mcs2 = Chem.MolFromSmarts(s3a4_mcs_80.smartsString)

Draw.MolsToGridImage([s3a4_mcs1, s3a4_mcs2], legends=["MCS1", "MCS2 with threshold = 0.8"])
```

<br>

###### **Moderate CYP3A4 inhibitors**

```{python}
#df_3a4_m_inh_p
```

```{python}
# Get list of RDKit mols
mols_m3a4 = list(df_3a4_m_inh_p["rdkit_mol"])

# Find MCS in mols
m3a4_mcs = rdFMCS.FindMCS(mols_m3a4)

# Get images of highlighted MCS for moderate CYP3A4 inhibitors
Draw.MolsToGridImage(
    mols_m3a4, 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_3a4_s_inh_p["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(m3a4_mcs.queryMol) for m in mols_m3a4]
    )
```

I just happend to spot a small code error above, so the MCS for moderate CYP3A4 inhibitors should be appearing for all here - aromatic (and macrolide) rings definitely involved.

<br>

###### **Combining moderate and strong CYP3A4 inhibitors**

Added in moderate CYP3A4 inhibitors to see if MCS changes.

```{python}
# Concatenate dfs for moderate & strong CYP3A4 inhibitors
df_3a4_all = pd.concat([df_3a4_s_inh_p, df_3a4_m_inh_p])
# index un-changed for now
print(df_3a4_all.shape)
df_3a4_all.head()
```

```{python}
mols_all = list(df_3a4_all["rdkit_mol"])
```

```{python}
# Find MCS for all CYP3A4 inhibitors
all_3a4_mcs = rdFMCS.FindMCS(mols_all)
```

```{python}
all_3a4_mcs.smartsString
```

```{python}
# All CYP3A4 inhibitors
Draw.MolsToGridImage(
    mols_all, 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_3a4_all["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(all_3a4_mcs.queryMol) for m in mols_all]
    )
```

It appeared the MCS for most of them involved rings (e.g. cycloalkane, aromatic and macrolide ones). So looking at ring bonds matching next.

```{python}
# matching ring bonds (if any)
all_3a4_mcs_ring = rdFMCS.FindMCS(mols_all, ringMatchesRingOnly=True)
```

```{python}
Draw.MolsToGridImage(
    mols_all, 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_3a4_all["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(all_3a4_mcs_ring.queryMol) for m in mols_all]
    )
```

Using queryMol to show the MCS structural outline for all CYP3A4 inhibitors, and each separate group of strong or moderate inhibitors.

```{python}
all_3a4_mcs_ring.queryMol
```

```{python}
s3a4_mcs.queryMol
```

```{python}
m3a4_mcs.queryMol
```

<br>

###### **Looking at each drug class within strong CYP3A4 inhibitors**

There were 3 antifungals, 2 macrolides, about 5 antivirals and 4 kinase inhibitors (e.g. ceritinib, tucatinib, idelalisib, ribociclib) in the strong CYP3A4 inhibitor cohort. For people unfamiliar with these drugs, ChEMBL database do have "drug indications" recorded for each approved drug that you might be able to use to deduce what each drug is used for (I happened to know them mostly on top of my head due to my old role). The "drug indications" can be added into the SQL query at the beginning so that it'll be included into the dataframes.

###### **Antifungals**

```{python}
# MCS for all antifungals in strong CYP3A4 inhibitors
df_s3a4_antifungal = df_3a4_s_inh_p[df_3a4_s_inh_p["pref_name"].isin(("ITRACONAZOLE", "KETOCONAZOLE", "VORICONAZOLE"))]

s3a4_antif = rdFMCS.FindMCS(list(df_s3a4_antifungal["rdkit_mol"]))
s3a4_antif.queryMol
```

<br>

###### **Macrolides**

```{python}
# All macrolides in strong CYP3A4 inhibitors
df_s3a4_macro = df_3a4_s_inh_p[df_3a4_s_inh_p["pref_name"].isin(("CLARITHROMYCIN", "TELITHROMYCIN"))]
df_s3a4_macro
```

Just to clarify, telithromycin is actually a [ketolide antibacterial](https://www.accessdata.fda.gov/drugsatfda_docs/label/2015/021144s019lbl.pdf#page=1), which is very similar to macrolide antibiotics (clarithromycin in this case).

```{python}
# Just showing how similar clarithromycin & telithromycin are in their structures
Draw.MolsToGridImage(
    list(df_s3a4_macro["rdkit_mol"]), 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_s3a4_macro["pref_name"])
    )
```

```{python}
# MCS for all macrolides in strong CYP3A4 inhibitors
s3a4_macro = rdFMCS.FindMCS(list(df_s3a4_macro["rdkit_mol"]))
s3a4_macro.queryMol
```

The typical macrolide-associated 14-membered ring [@Douthwaite2001] was shown in the MCS for both drugs.

<br>

###### **Antivirals**

```{python}
# All antivirals in strong CYP3A4 inhibitors
df_s3a4_antiv = df_3a4_s_inh_p[df_3a4_s_inh_p["pref_name"].isin(("INDINAVIR", "NELFINAVIR", "RITONAVIR", "SAQUINAVIR", "TELAPREVIR"))]
df_s3a4_antiv
```

```{python}
# Images of antivirals
Draw.MolsToGridImage(
    list(df_s3a4_antiv["rdkit_mol"]), 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_s3a4_antiv["pref_name"])
    )
```

```{python}
# MCS for all antivirals
s3a4_antiv = rdFMCS.FindMCS(list(df_s3a4_antiv["rdkit_mol"]))
s3a4_antiv.queryMol
```

```{python}
# Highlighting MCS for antivirals
Draw.MolsToGridImage(
    list(df_s3a4_antiv["rdkit_mol"]), 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_s3a4_antiv["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(s3a4_antiv.queryMol) for m in list(df_s3a4_antiv["rdkit_mol"])]
    )
```

I also thought about trying to align these 5 antivirals to see if this was possible.

```{python}
# rdkit.Chem.rdDepictor.GenerateDepictionMatching2DStructure()
# https://www.rdkit.org/docs/source/rdkit.Chem.rdDepictor.html#rdkit.Chem.rdDepictor.GenerateDepictionMatching2DStructure

# Below example code from RDKit docs
# https://www.rdkit.org/docs/GettingStartedInPython.html#working-with-2d-molecules-generating-depictions

# # Using a template mol
# template = Chem.MolFromSmiles('c1nccc2n1ccc2')
# AllChem.Compute2DCoords(template)

# # Set of mols to compare with template mol
# ms = [Chem.MolFromSmiles(smi) for smi in ('OCCc1ccn2cnccc12','C1CC1Oc1cc2ccncn2c1','CNC(=O)c1nccc2cccn12')]

# for m in ms:
#     _ = AllChem.GenerateDepictionMatching2DStructure(m,template)
# Draw.MolsToGridImage(ms, molsPerRow=4, subImgSize=(200,200))
```

```{python}
# Having a look at antiviral df again
#df_s3a4_antiv
```

If trying to align these 5 antivirals, it would fail the first time and then if I turned on the "acceptFailure" mode then it would be like this below. Ideally, it should be used on a series of analogues or SAR analysis (probably not to be used like this, but I was just curious).

```{python}
# Reference mol - indinavir
temp = df_s3a4_antiv.loc[3, "rdkit_mol"]

# Set of mols to compare - rest of antivirals
mols_antiv = df_s3a4_antiv.loc[10:, "rdkit_mol"]

for mol in mols_antiv:
    _ = AllChem.GenerateDepictionMatching2DStructure(mol,temp, acceptFailure = False)

Draw.MolsToGridImage(mols_antiv, molsPerRow=2, subImgSize=(400, 300), legends=list(df_s3a4_antiv["pref_name"]))

# Unable to align if not setting acceptFailure = True - "Depict error: Substructure match with reference not found"
```

<br>

###### **Kinase inhibitors**

```{python}
#df_3a4_s_inh_p
```

```{python}
# All kinase inhibitors 
df_s3a4_ki = df_3a4_s_inh_p[df_3a4_s_inh_p["pref_name"].isin(("CERITINIB", "IDELALISIB", "RIBOCICLIB", "TUCATINIB"))]
df_s3a4_ki
```

```{python}
# MCS for all kinase inhibitors
s3a4_ki = rdFMCS.FindMCS(list(df_s3a4_ki["rdkit_mol"]))
s3a4_ki.queryMol
```

```{python}
# Highlighting MCS for kinase inhibitors
Draw.MolsToGridImage(
    list(df_s3a4_ki["rdkit_mol"]), 
    subImgSize=(400, 300), 
    molsPerRow=2, 
    legends = list(df_s3a4_ki["pref_name"]), highlightAtomLists=[m.GetSubstructMatch(s3a4_ki.queryMol) for m in list(df_s3a4_ki["rdkit_mol"])]
    )
```

Pyrimidine ring (or part of fused pyrimidine derivatives in some cases) was shown in MCS highlighting for all 4 kinase inhibitors.

<br>

###### **Back to all CYP3A4 inhibitors again**

Likely last thing to try next:

The idea came from a RDKit post by Paolo Tosco on, "[New MCS features in 2023.09.1](https://greglandrum.github.io/rdkit-blog/posts/2023-10-27-mcswhatsnew.html)"

* AtomCompare & BondCompare -> looking at elements/bond orders/aromaticities in ring systems OR

* custom subclasses in AtomCompare & BondCompare -> looking at elements/bond orders/aromaticities in non-ring systems

i.e. customise parameters e.g. rdFMCS.MCSParameters()

Since it appeared that the MCS found above for all (moderate & strong) CYP3A4 inhibitors involved rings quite a bit, I might try the second option first.

<br>

###### **Other things to consider**

Thinking about stereochemistry of the mols (?to look into this further):

e.g. MCSBondCompare() class

-> CheckBondRingMatch()

-> CheckBondStereo()

e.g. MCSBondCompareParameter() class

-> MatchFusedRings

-> CompleteRingsOnly

-> MatchStereo (to include bond stereo in comparison)



```{python}
## Reference code borrowed from https://gist.github.com/iwatobipen/6d8708d8c77c615cfffbb89409be730d by iwatobipen

# from rdkit import Chem
# from rdkit.Chem import Draw
#from rdkit.Chem.Draw import IPythonConsole
# from rdkit.Chem import rdFMCS
# from rdkit.Chem.Draw import rdDepictor
# rdDepictor.SetPreferCoordGen(True)
# IPythonConsole.drawOptions.minFontSize=20

# def view_difference(mol1, mol2):
#     mcs = rdFMCS.FindMCS([mol1,mol2])
#     mcs_mol = Chem.MolFromSmarts(mcs.smartsString)
#     match1 = mol1.GetSubstructMatch(mcs_mol)
#     target_atm1 = []
#     for atom in mol1.GetAtoms():
#         if atom.GetIdx() not in match1:
#             target_atm1.append(atom.GetIdx())
#     match2 = mol2.GetSubstructMatch(mcs_mol)
#     target_atm2 = []
#     for atom in mol2.GetAtoms():
#         if atom.GetIdx() not in match2:
#             target_atm2.append(atom.GetIdx())
#     return Draw.MolsToGridImage([mol1, mol2],highlightAtomLists=[target_atm1, target_atm2])
```

<br>

###### **Strong CYP2D6 inhibitors**

To be continued.

<br>

###### **Moderate CYP2D6 inhibitors**

To be continued.

<br>

###### **Combining moderate & strong CYP2D6 inhibitors**

To be continued.

<br>

##### **Future work**

Future posts may involve looking at other CYPs, particularly on other inhibitors and substrates. Inducers are a different story as they tend to increase drug metabolisms via CYP inductions, which are more likely to do with losing therapeutic effects than gaining adverse effects.