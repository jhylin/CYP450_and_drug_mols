---
title: "Cytochrome P450 and small molecules"
author: Jennifer HY Lin
date: '2024-7-8'
draft: true
categories: 
    - Toxicology
    - RDKit
    - ChEMBL database
    - Python
jupyter: python3
format: html
bibliography: references.bib
---

Something about drug toxicology.

Seems to involve (in a very rough sense) 3 main types: structural alerts (in relation to known adverse effects or PAINs), Human ether-a-go-go-related gene (hERG) potassium channel and cytochrome P450 (CYP450) enzymes. There are most likely more as well (need to look further into).

Recent commentary that mentions about "avoidome" - "Structure is beauty, but not always truth" (cite: https://doi.org/10.1016/j.cell.2024.01.003) talks about DMPK-related proteins to avoid 
- also mentioned two other blog posts which have reviewed this commentary recently (interesting view points)
- https://www.science.org/content/blog-post/john-keats-would-word - D. Lowe
- https://fbdd-lit.blogspot.com/2024/03/ - P. Kenny

Many have looked into structural alerts (one example repo - rd_filters). ChEMBL database also has a cheminformatic utils web service that provides structural alert computation for compounds. There are most likely many more (probably need to search for more).

hERG potassium channel is also another frequently-looked aspect for drug toxicology due to its effect on cardiac QT prolongation.

CYP450 enzymes also play a key role in the toxicology part of ADMET process of therapeutic drugs, I thought to look into the relationship between CYP450 and small drug molecules initially to see if there is anything interesting for further explorations.

There is a nice background reading on the history involving CYP450 and their relevance to toxicities in drugs - https://doi.org/10.1007/s43188-020-00056-z. I don't think I can do a better job than this piece (or there may be more in the literatures) but this one sticks out for me at the time.

<br>

##### **Extracting data**

```{python}
import pandas as pd
import chembl_downloader
from chembl_downloader import latest
```

```{python}
# Latest version of ChEMBL
latest_version = latest()
print(f"The latest ChEMBL version is: {latest_version}")
```

I'm using SQL via chembl_downloader again to download approved drugs with their ChEMBL ID and equivalent canonical SMILES. All of the CYP3A4 inhibitors extracted from ChEMBL are based on the [Flockhart table of drug interactions](https://drug-interactions.medicine.iu.edu/MainTable.aspx).

Note: Three other categories of medicines are not going to be looked at currently, which are the weak inhibitors, ones with in vitro evidence only and ones that are still pending reviews.

A bit about retrieving data here, the following might not be the best way to get the data, but I've somehow incorporated chembl_downloader into my own small piece of function code to retrieve SMILES of approved drugs. Earlier on, I was repeating SQL queries and thought to improve them by using a function code instead - see Python script named as "cyp_drugs.py". It removes a large chunk of SQL query string every time when trying to get different CYP inhibitors, leaving only approved drug names so it's easier to read and understand.

Another possible way is to use get_target_sql(), e.g. using a specific CYP enzyme as the protein target to retrieve data, but it appears that there are no clear data marked to indicate the potency of CYP inhibition or induction (i.e. weak, moderate or strong) in the ChEMBL database (an example link for CYP2D6 in ChEMBL - https://www.ebi.ac.uk/chembl/web_components/explore/activities/STATE_ID:pxs_ydUxNelxmAa9ckYEPw%3D%3D). The Flockhart table has clearly annotated each approved drug with journal paper citations, so I'm going to stick with the following method for now.

```{python}
## Main issue previously was with sql string - too many quotation marks!
# e.g. WHERE molecule_dictionary.pref_name = '('KETOCONAZOLE', 'FLUCONAZOLE')'': near "KETOCONAZOLE": syntax error
# Resolved by adding string methods e.g. strip() and replace() to sql query string
# function code used chembl_downloader code as reference since it has no particular function to select drugs this way yet
from cyp_drugs import chembl_drugs

# Get a list of strong cyp3a4 inhibitors
# and save as a tsv file
df_3a4_strong_inh = chembl_drugs(
    "CERITINIB", "CLARITHROMYCIN", "DELAVIRIDINE", "IDELALISIB", "INDINAVIR", "ITRACONAZOLE", "KETOCONAZOLE", "MIBEFRADIL", "NEFAZODONE", "NELFINAVIR", "RIBOCICLIB", "RITONAVIR", "SAQUINAVIR", "TELAPREVIR", "TELITHROMYCIN", "TUCATINIB", "VORICONAZOLE",
    #file_name="strong_3a4_inh"
    )
df_3a4_strong_inh
```

```{python}
## Get a list of moderate cyp3a4 inhibitors
# skipping grapefruit juice as it's not quite an approved drug...
# note: amlodipine inhibits cyp3a5
df_3a4_mod_inh = chembl_drugs(
    "AMLODIPINE", "APREPITANT", "CIPROFLOXACIN", "CRIZOTINIB", "DILTIAZEM", "ERYTHROMYCIN", "FLUCONAZOLE", "IMATINIB", "LETERMOVIR", "NETUPITANT", "VERAPAMIL", #file_name="mod_3a4_inh"
    )
df_3a4_mod_inh
```

```{python}
# Get a list of strong cyp2d6 inhibitors
df_2d6_strong_inh = chembl_drugs(
    "BUPROPION", "FLUOXETINE", "PAROXETINE", "QUINIDINE", 
    #file_name="strong_2d6_inh"
    )
df_2d6_strong_inh
```

```{python}
# Get a list of moderate cyp2d6 inhibitors
df_2d6_mod_inh = chembl_drugs(
    "ABIRATERONE", "CINACALCET", "CLOBAZAM", "DOXEPIN", "DULOXETINE", "HALOFANTRINE", "LORCASERIN", "MOCLOBEMIDE", "ROLAPITANT", "TERBINAFINE", 
    #file_name="mod_2d6_inh"
    )
df_2d6_mod_inh
```

Initially, four categories of approved drugs are retrieved - strong CYP3A4/5 inhibitors, moderate CYP3A4/5 inhibitors, strong CYP2D6 inhibitors and moderate CYP2D6 inhibitors.

This group of drugs inhibiting CYP3A4/5 is the largest cohort of all the cytochrome inhibitors. When a drug behaves like a cytochrome inhibitor, it inhibits the activity of a particular cytochrome enzyme e.g. CYP3A4 leading to a reduction of clearance of a particular therapeutic drug e.g. a CYP3A4 substrate such as apixaban, thus increasing its plasma concentration in vivo causing higher chance of adverse effect (which in the context of apixaban, this means the poor person who's taken apixaban may get excessive bleeding!).

<br>

##### **Import and preprocess data**

* Will look at the two largest group of CYP inhibitors first (may need to include substrates and inducers too - depends on how this will go...)

* Any interesting molecular motifs/substructures?

```{python}
## Tried using pandas 2.2.2, numpy 2.0.0 and rdkit 2024.3.1 (all latest major versions, note: rdkit has a latest minor release as 2024.03.4, which includes a patch for numpy 2.0)
# Seems to work as a new df is generated but with some error messages shown though
# ---error message---
# A module that was compiled using NumPy 1.x cannot be run in
# NumPy 2.0.0 as it may crash. To support both 1.x and 2.x
# versions of NumPy, modules must be compiled with NumPy 2.0.
# Some module may need to rebuild instead e.g. with 'pybind11>=2.12'.
# If you are a user of the module, the easiest solution will be to
# downgrade to 'numpy<2' or try to upgrade the affected module.
# We expect that some modules will need time to support NumPy 2.


## 2 other possible things to try:
# download latest rdkit patch 2024.03.4 (will look into?) or
# downgrade pandas and numpy - confirmed that it worked with pandas 2.1.4 & numpy 1.26.4 with no error messages as output

# preprocess canonical smiles 
from mol_prep import preprocess

# cyp3a4 strong inhibitors
df_3a4_s_inh = df_3a4_strong_inh.copy()
df_3a4_s_inh_p = df_3a4_s_inh.apply(preprocess, axis=1)
df_3a4_s_inh_p.head(3)
```

```{python}
# cyp3a4 moderate inhibitors
df_3a4_m_inh = df_3a4_mod_inh.copy()
df_3a4_m_inh_p = df_3a4_m_inh.apply(preprocess, axis=1)
df_3a4_m_inh_p.head()
```

```{python}
# cyp2d6 strong inhibitors
df_2d6_s_inh = df_2d6_strong_inh.copy()
df_2d6_s_inh_p = df_2d6_s_inh.apply(preprocess, axis=1)
df_2d6_s_inh_p
```

```{python}
#cyp2d6 moderate inhibitors
df_2d6_m_inh = df_2d6_mod_inh.copy()
df_2d6_m_inh_p = df_2d6_m_inh.apply(preprocess, axis=1)
df_2d6_m_inh_p
```

##### **Images of structures**

* Checking structural validities

```{python}
from rdkit.Chem import Draw
from rdkit.Chem.Draw import IPythonConsole
IPythonConsole.ipython_useSVG=True

# 2d6 mod inhibitors
image_2d6_m_inh = Draw.MolsToGridImage(df_2d6_m_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(250, 250), legends=list(df_2d6_m_inh_p["pref_name"]))
image_2d6_m_inh
```


```{python}
# 2d6 strong inhibitors
image_2d6_s_inh = Draw.MolsToGridImage(df_2d6_s_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(250, 250), legends=list(df_2d6_s_inh_p["pref_name"]))
image_2d6_s_inh
```

* Will need to check quinidine - two entries
* Noted different stereochem between the two quinidines (may remove the first one?)

```{python}
# 3a4 mod inhibitors
image_3a4_m_inh = Draw.MolsToGridImage(df_3a4_m_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(250, 250), legends=list(df_3a4_m_inh_p["pref_name"]))
image_3a4_m_inh
```

```{python}
# 3a4 strong inhibitors
image_3a4_s_inh = Draw.MolsToGridImage(df_3a4_s_inh_p["rdkit_mol"], molsPerRow=3, subImgSize=(250, 250), legends=list(df_3a4_s_inh_p["pref_name"]))
image_3a4_s_inh
```

* Two itraconazoles to check - may need to remove one?
* 3 antifungals, 2 macrolides, about 5 antivirals and 4 kinase inhibitors (ceritinib, tucatinib, idelalisib, ribociclib) in this category
* MCS might be interesting to look at in this group of strong 3A4 inhibitors

```{python}
# Check MCS first - may edit following code?

## Following code borrowed from https://gist.github.com/iwatobipen/6d8708d8c77c615cfffbb89409be730d by iwatobipen


# from rdkit import Chem
# from rdkit.Chem import Draw
# from rdkit.Chem.Draw import IPythonConsole
# from rdkit.Chem import rdFMCS
# from rdkit.Chem.Draw import rdDepictor
# rdDepictor.SetPreferCoordGen(True)
# IPythonConsole.drawOptions.minFontSize=20


# def view_difference(mol1, mol2):
#     mcs = rdFMCS.FindMCS([mol1,mol2])
#     mcs_mol = Chem.MolFromSmarts(mcs.smartsString)
#     match1 = mol1.GetSubstructMatch(mcs_mol)
#     target_atm1 = []
#     for atom in mol1.GetAtoms():
#         if atom.GetIdx() not in match1:
#             target_atm1.append(atom.GetIdx())
#     match2 = mol2.GetSubstructMatch(mcs_mol)
#     target_atm2 = []
#     for atom in mol2.GetAtoms():
#         if atom.GetIdx() not in match2:
#             target_atm2.append(atom.GetIdx())
#     return Draw.MolsToGridImage([mol1, mol2],highlightAtomLists=[target_atm1, target_atm2])
```



?fragments and other things